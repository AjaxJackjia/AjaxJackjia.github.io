title: "排序算法 && 查找算法 (1)"
date: 2015-04-03 12:24:21
category: 
- Knowledge
tags:
- 总结
- 提纲
- 算法
- 排序
- 查找
---

# 排序算法

## 1. 内部排序

| 排序方法      | 平均情况      | 最好情况      | 最坏情况      | 辅助空间      | 是否稳定      | 排序类型      |
|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|
| 冒泡排序      |  $O(n^2)$		|  $O(n)$		|  $O(n^2)$		|  $O(1)$		|  是    		|  比较 		|
| 简单选择排序  |  $O(n^2)$		|  $O(n^2)$		|  $O(n^2)$		|  $O(1)$		|  **不**   	|  比较 		|	
| 直接插入排序  |  $O(n^2)$		|  $O(n)$		|  $O(n^2)$		|  $O(1)$		|  是 	    	|  比较 		|
| 希尔排序      |  $O(nlogn)-O(n^2)$|  $O(n^{1.3})$|  $O(n^2)$	|  $O(1)$		|  **不**		|  比较 		|
| 堆排序        |  $O(nlogn)$	|  $O(nlogn)$	|  $O(nlogn)$	|  $O(1)$		|  **不**		|  比较 		|
| 归并排序      |  $O(nlogn)$	|  $O(nlogn)$	|  $O(nlogn)$	|  $O(n)$   	|  是			|  比较 		|
| 快速排序      |  $O(nlogn)$	|  $O(nlogn)$	|  $O(n^2)$		|  $O(logn)-O(n)$| **不**		|  比较 		|
| 计数排序      |  $O(n)$		|  -			|  -			|  -			|  是			|  非比较   	|
| 桶排序	    |  $O(n)$		|  -			|  -			|  -			|  是			|  非比较   	|
| 基数排序      |  $O(n)$		|  -			|  -			|  -			|  是			|  非比较   	|

### 1.1 比较排序	

#### 冒泡排序

基本思想是:两两比较相邻记录的关键字,如果反序则交换。
冒泡排序时间复杂度最好的情况为$O(n)$,最坏的情况是$O(n^2)$。

改进思路1：设置标志位，明显如果有一趟没有发生交换（flag = false)，说明排序已经完成。
改进思路2：记录一轮下来标记的最后位置，下次从头部遍历到这个位置就Ok。
改进思路3：双向扫描，鸡尾酒排序。

[补充冒泡排序](http://www.cnblogs.com/flyingbread/archive/2007/01/26/630674.html)

#### 直接插入排序

将一个记录插入到已经排好序的有序表中, 从而得到一个新的,记录数增1的有序表。时间复杂度也为O(n^2)， 比冒泡法和选择排序的性能要更好一些。

[插入排序](http://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F)

#### 简单选择排序

通过n-i次关键字之间的比较,从n-i+1 个记录中选择关键字最小的记录,并和第i(1<=i<=n)个记录交换之，尽管与冒泡排序同为O(n^2),但简单选择排序的性能要略优于冒泡排序。

[选择排序](http://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F)

#### 希尔排序

先将整个待排元素序列分割成若干子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序（增量为1）。其时间复杂度为O(n^3/2),要好于直接插入排序的O(n^2)。

[希尔排序1](http://zh.wikipedia.org/zh/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F)
[希尔排序2](http://blog.csdn.net/morewindows/article/details/6668714)

#### 堆排序

堆是具有下列性质的完全二叉树:每个节点的值都大于或等于其左右孩子节点的值,称为大顶堆；或者每个节点的值都小于或等于其左右孩子节点的值,称为小顶堆。

堆排序就是利用堆进行排序的方法。基本思想是:将待排序的序列构造成一个大顶堆。此时,整个序列的最大值就是堆顶的根结点。将它移走(其实就是将其与堆数组的末尾元素交换, 此时末尾元素就是最大值),然后将剩余的n-1个序列重新构造成一个堆,这样就会得到n个元素的次大值。如此反复执行,便能得到一个有序序列了。 时间复杂度为 O(nlogn),好于冒泡,简单选择,直接插入的O(n^2)。

#### 归并排序

假设初始序列含有n个记录,则可以看成n个有序的子序列,每个子序列的长度为1,然后两两归并,得到(不小于n/2的最小整数)个长度为2或1的有序子序列,再两两归并,...如此重复,直至得到一个长度为n的有序序列为止,这种排序方法称为2路归并排序。 时间复杂度为O(nlogn),空间复杂度为O(n+logn),如果非递归实现归并,则避免了递归时深度为logn的栈空间 空间复杂度为O(n)。

#### 快速排序

过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。时间复杂度为O(nlogn)。


### 1.2 非比较排序

#### 计数排序

计数排序(Counting sort)是一种稳定的排序算法。计数排序假设n个输入元素中的每一个元素都是介于0~k之间的整数。计数排序的基本思想是对每一个输入元素x，确定出小于x的元素个数。有了这个信息就可以把x放到它最终输出数组中的位置上。

计数排序使用一个额外的数组C[0,...,k]，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。算法的步骤如下：
* 找出待排序的数组中最大元素；
* 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
* 对所有的计数累加（从C中的位置为1的元素开始，每一项和前一项相加）；
* 反向填充目标数组：将每个元素i放在新数组B的第C(i)项，每放一个元素就将C(i)减去1。（**反向填充**的目的是保证排序的**稳定性**）

由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。

#### 基数排序

基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。这个算法很重要的一点就是按位排序要稳定。

实现过程为：
* 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零；
* 从最低位开始，依次进行一次排序（使用任意一种**稳定排序**，可以用上述的计数排序）；

这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。

#### 桶排序

当桶排序(Bucket sort)的输入符合均匀分布时，即可以以线性期望时间运行。具体来说，计数排序假设输入是由一个小范围内的整数构成，而桶排序则假设输入由一个随机过程产生，该过程将元素均匀而独立地分布在区间[0,1)上。

桶排序的思想是：
* 把区间[0,1)划分成n个相同大小的子区间，或称为桶；
* 将n个输入分布到各个桶中，因为输入数字均匀分布在区间[0,1)上，所以一般不会有很多数落在一个桶中的情况；
* 对各个桶中元素进行排序（可以进行插入排序）；
* 按次序把各个桶中的元素输出即可。

## 2. 外部排序

外部排序是指大量数据的排序，通常待排序的数据保存在外存储器上（比如硬盘），待排序的文件无法一次装入内存，需要在内存和硬盘之间进行多次数据交换，以达到排序整个文件的目的。

外部排序最常用的算法是**多路归并排序**（利用**最小堆**或者**败者树**进行归并操作），**位图方案**也可以用在外部排序中（没有重复数字）。


[外排序](http://www.cnblogs.com/huangxincheng/archive/2012/12/19/2824943.html)
[外部排序](http://noalgo.info/666.html)
[如何给10^7个数据量的磁盘文件排序](http://blog.csdn.net/v_JULY_v/article/details/6451990)

## Reference

[http://blog.csdn.net/jnu_simba/article/details/9705111](http://blog.csdn.net/jnu_simba/article/details/9705111)
 

