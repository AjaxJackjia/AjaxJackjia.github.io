<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="自由·至简·宁静">
<meta property="og:type" content="website">
<meta property="og:title" content="Jack Jia">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Jack Jia">
<meta property="og:description" content="自由·至简·宁静">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jack Jia">
<meta name="twitter:description" content="自由·至简·宁静">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Jack Jia </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?5e5d756ee86b47c3c2339a80b083f4a6";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Jack Jia</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">慵懒的探索者</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-books">
          <a href="/books" rel="section">
            
              <i class="menu-item-icon fa fa-book fa-fw"></i> <br />
            
            读书
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/sorting-algorithm/" itemprop="url">
                  排序算法 && 查找算法 (1)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-03T12:24:21+08:00" content="2015-04-03">
              2015-04-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index">
                    <span itemprop="name">Knowledge</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/sorting-algorithm/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="sorting-algorithm/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/sorting-algorithm/" class="leancloud_visitors" data-flag-title="排序算法 && 查找算法 (1)">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="1-内部排序"><a href="#1-内部排序" class="headerlink" title="1. 内部排序"></a>1. 内部排序</h2><table>
<thead>
<tr>
<th style="text-align:center">排序方法</th>
<th style="text-align:center">平均情况</th>
<th style="text-align:center">最好情况</th>
<th style="text-align:center">最坏情况</th>
<th style="text-align:center">辅助空间</th>
<th style="text-align:center">是否稳定</th>
<th style="text-align:center">排序类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">是</td>
<td style="text-align:center">比较</td>
</tr>
<tr>
<td style="text-align:center">简单选择排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center"><strong>不</strong></td>
<td style="text-align:center">比较</td>
</tr>
<tr>
<td style="text-align:center">直接插入排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">是</td>
<td style="text-align:center">比较</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">$O(nlogn)-O(n^2)$</td>
<td style="text-align:center">$O(n^{1.3})$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center"><strong>不</strong></td>
<td style="text-align:center">比较</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">$O(nlogn)$</td>
<td style="text-align:center">$O(nlogn)$</td>
<td style="text-align:center">$O(nlogn)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center"><strong>不</strong></td>
<td style="text-align:center">比较</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">$O(nlogn)$</td>
<td style="text-align:center">$O(nlogn)$</td>
<td style="text-align:center">$O(nlogn)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">是</td>
<td style="text-align:center">比较</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">$O(nlogn)$</td>
<td style="text-align:center">$O(nlogn)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(logn)-O(n)$</td>
<td style="text-align:center"><strong>不</strong></td>
<td style="text-align:center">比较</td>
</tr>
<tr>
<td style="text-align:center">计数排序</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">是</td>
<td style="text-align:center">非比较</td>
</tr>
<tr>
<td style="text-align:center">桶排序</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">是</td>
<td style="text-align:center">非比较</td>
</tr>
<tr>
<td style="text-align:center">基数排序</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">是</td>
<td style="text-align:center">非比较</td>
</tr>
</tbody>
</table>
<h3 id="1-1-比较排序"><a href="#1-1-比较排序" class="headerlink" title="1.1 比较排序"></a>1.1 比较排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>基本思想是:两两比较相邻记录的关键字,如果反序则交换。<br>冒泡排序时间复杂度最好的情况为$O(n)$,最坏的情况是$O(n^2)$。</p>
<p>改进思路1：设置标志位，明显如果有一趟没有发生交换（flag = false)，说明排序已经完成。<br>改进思路2：记录一轮下来标记的最后位置，下次从头部遍历到这个位置就Ok。<br>改进思路3：双向扫描，鸡尾酒排序。</p>
<p><a href="http://www.cnblogs.com/flyingbread/archive/2007/01/26/630674.html" target="_blank" rel="external">补充冒泡排序</a></p>
<h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>将一个记录插入到已经排好序的有序表中, 从而得到一个新的,记录数增1的有序表。时间复杂度也为O(n^2)， 比冒泡法和选择排序的性能要更好一些。</p>
<p><a href="http://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" target="_blank" rel="external">插入排序</a></p>
<h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><p>通过n-i次关键字之间的比较,从n-i+1 个记录中选择关键字最小的记录,并和第i(1&lt;=i&lt;=n)个记录交换之，尽管与冒泡排序同为O(n^2),但简单选择排序的性能要略优于冒泡排序。</p>
<p><a href="http://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" target="_blank" rel="external">选择排序</a></p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>先将整个待排元素序列分割成若干子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序（增量为1）。其时间复杂度为O(n^3/2),要好于直接插入排序的O(n^2)。</p>
<p><a href="http://zh.wikipedia.org/zh/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="external">希尔排序1</a><br><a href="http://blog.csdn.net/morewindows/article/details/6668714" target="_blank" rel="external">希尔排序2</a></p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆是具有下列性质的完全二叉树:每个节点的值都大于或等于其左右孩子节点的值,称为大顶堆；或者每个节点的值都小于或等于其左右孩子节点的值,称为小顶堆。</p>
<p>堆排序就是利用堆进行排序的方法。基本思想是:将待排序的序列构造成一个大顶堆。此时,整个序列的最大值就是堆顶的根结点。将它移走(其实就是将其与堆数组的末尾元素交换, 此时末尾元素就是最大值),然后将剩余的n-1个序列重新构造成一个堆,这样就会得到n个元素的次大值。如此反复执行,便能得到一个有序序列了。 时间复杂度为 O(nlogn),好于冒泡,简单选择,直接插入的O(n^2)。</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>假设初始序列含有n个记录,则可以看成n个有序的子序列,每个子序列的长度为1,然后两两归并,得到(不小于n/2的最小整数)个长度为2或1的有序子序列,再两两归并,…如此重复,直至得到一个长度为n的有序序列为止,这种排序方法称为2路归并排序。 时间复杂度为O(nlogn),空间复杂度为O(n+logn),如果非递归实现归并,则避免了递归时深度为logn的栈空间 空间复杂度为O(n)。</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。时间复杂度为O(nlogn)。</p>
<h3 id="1-2-非比较排序"><a href="#1-2-非比较排序" class="headerlink" title="1.2 非比较排序"></a>1.2 非比较排序</h3><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>计数排序(Counting sort)是一种稳定的排序算法。计数排序假设n个输入元素中的每一个元素都是介于0~k之间的整数。计数排序的基本思想是对每一个输入元素x，确定出小于x的元素个数。有了这个信息就可以把x放到它最终输出数组中的位置上。</p>
<p>计数排序使用一个额外的数组C[0,…,k]，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。算法的步骤如下：</p>
<ul>
<li>找出待排序的数组中最大元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加（从C中的位置为1的元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组B的第C(i)项，每放一个元素就将C(i)减去1。（<strong>反向填充</strong>的目的是保证排序的<strong>稳定性</strong>）</li>
</ul>
<p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。这个算法很重要的一点就是按位排序要稳定。</p>
<p>实现过程为：</p>
<ul>
<li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零；</li>
<li>从最低位开始，依次进行一次排序（使用任意一种<strong>稳定排序</strong>，可以用上述的计数排序）；</li>
</ul>
<p>这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。</p>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p>当桶排序(Bucket sort)的输入符合均匀分布时，即可以以线性期望时间运行。具体来说，计数排序假设输入是由一个小范围内的整数构成，而桶排序则假设输入由一个随机过程产生，该过程将元素均匀而独立地分布在区间[0,1)上。</p>
<p>桶排序的思想是：</p>
<ul>
<li>把区间[0,1)划分成n个相同大小的子区间，或称为桶；</li>
<li>将n个输入分布到各个桶中，因为输入数字均匀分布在区间[0,1)上，所以一般不会有很多数落在一个桶中的情况；</li>
<li>对各个桶中元素进行排序（可以进行插入排序）；</li>
<li>按次序把各个桶中的元素输出即可。</li>
</ul>
<h2 id="2-外部排序"><a href="#2-外部排序" class="headerlink" title="2. 外部排序"></a>2. 外部排序</h2><p>外部排序是指大量数据的排序，通常待排序的数据保存在外存储器上（比如硬盘），待排序的文件无法一次装入内存，需要在内存和硬盘之间进行多次数据交换，以达到排序整个文件的目的。</p>
<p>外部排序最常用的算法是<strong>多路归并排序</strong>（利用<strong>最小堆</strong>或者<strong>败者树</strong>进行归并操作），<strong>位图方案</strong>也可以用在外部排序中（没有重复数字）。</p>
<p><a href="http://www.cnblogs.com/huangxincheng/archive/2012/12/19/2824943.html" target="_blank" rel="external">外排序</a><br><a href="http://noalgo.info/666.html" target="_blank" rel="external">外部排序</a><br><a href="http://blog.csdn.net/v_JULY_v/article/details/6451990" target="_blank" rel="external">如何给10^7个数据量的磁盘文件排序</a></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://blog.csdn.net/jnu_simba/article/details/9705111" target="_blank" rel="external">http://blog.csdn.net/jnu_simba/article/details/9705111</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/gvim-personalization/" itemprop="url">
                  gvim个性化配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-28T21:51:28+08:00" content="2015-03-28">
              2015-03-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/开发工具/" itemprop="url" rel="index">
                    <span itemprop="name">开发工具</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/gvim-personalization/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="gvim-personalization/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/gvim-personalization/" class="leancloud_visitors" data-flag-title="gvim个性化配置">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>知道vim是很久之前的事情了，但是一直没有上手练习那些命令，最近才开始捡起来vim的命令，感觉非常高效。但是gvim一开始的界面非常丑，还是需要自己配置下才看着舒服，用着也顺手。下面是我自己常用的vim界面配置。</p>
<pre><code class="language-bash">
if has("gui_running")
  set nobackup
  set guifont=YaHei_Consolas_Hybrid:h12
  set nu
  set ts=4
  set expandtab
  colo desert
  set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1
  set fileencoding=utf-8
endif
</code></pre>

<p><a class="cotent-img" href="/uploads/2015/3/gvim配色方案.png"><br>    <img src="/uploads/2015/3/gvim配色方案.png" alt="gvim配色方案"><br></a></p>
<p>gui字体配置是使用set guifont命令，具体格式为set guifont=字体:字号。</p>
<p>主题设置是colo命令，gvim下面的配色方案有</p>
<ul>
<li>blue</li>
<li>darkblue</li>
<li>default</li>
<li>delek</li>
<li>desert</li>
<li>elflord</li>
<li>evening</li>
<li>koehler</li>
<li>morning</li>
<li>murphy</li>
<li>pablo</li>
<li>peachpuff</li>
<li>ron</li>
<li>shine</li>
<li>slate</li>
<li>torte</li>
<li>zellner</li>
</ul>
<p>set nu设置显示行号。</p>
<p>set fileencodings是设置文件读入时的编码侯选集；set fileencoding是设置写入文件时的编码方案。</p>
<p>另外，如果觉得vim保存文件之后有默认备份不太好，则可以在vim目录下的vimrc_example.vim中设置，将第27行改为set nobackup。</p>
<pre data-line="27" data-line-offset="23"><code class="language-bash">
if has("vms")
  set nobackup        // do not keep a backup file, use versions instead
else
  set nobackup        // keep a backup file 
endif
</code></pre>

<p>下面有必要说一下vim的编码方式。这里主要借鉴了<a href="http://edyfox.codecarver.org/html/vim_fileencodings_detection.html" target="_blank" rel="external">【vim的编码方式】</a>这篇文章。</p>
<h2 id="vim编码方式"><a href="#vim编码方式" class="headerlink" title="vim编码方式"></a>vim编码方式</h2><hr>
<p>在 Vim 中，有四个与编码有关的选项，它们是：fileencodings、fileencoding、encoding 和 termencoding。</p>
<h3 id="1-encoding"><a href="#1-encoding" class="headerlink" title="1. encoding"></a>1. encoding</h3><p>encoding 是 Vim 内部使用的字符编码方式。当设置了 encoding 之后，Vim 内部所有的 buffer、寄存器、脚本中的字符串等，全都使用这个编码。Vim 在工作的时候，如果编码方式与它的内部编码不一致，它会先把编码转换成内部编码。如果工作用的编码中含有无法转换为内部编码的字符，在这些字符就会丢失。因此，在选择 Vim 的内部编码的时候，一定要使用一种表现能力足够强的编码，以免影响正常工作。</p>
<p>由于 encoding 选项涉及到 Vim 中所有字符的内部表示，因此只能在 Vim 启动的时候设置一次。在 Vim 工作过程中修改 encoding 会造成非常多的问题。如果没有特别的理由，请始终将 encoding 设置为 utf-8。为了避免在非 UTF-8 的系统如 Windows 下，菜单和系统提示出现乱码，可同时做这几项设置：</p>
<pre><code class="language-bash">
set encoding=utf-8
set langmenu=zh_CN.UTF-8
language message zh_CN.UTF-8
</code></pre>

<h3 id="2-termencoding"><a href="#2-termencoding" class="headerlink" title="2. termencoding"></a>2. termencoding</h3><p>termencoding 是 Vim 用于屏幕显示的编码，在显示的时候，Vim 会把内部编码转换为屏幕编码，再用于输出。内部编码中含有无法转换为屏幕编码的字符时，该字符会变成问号，但不会影响对它的编辑操作。如果 termencoding 没有设置，则直接使用 encoding 不进行转换。</p>
<p>举个例子，当你在 Windows 下通过 telnet 登录 Linux 工作站时，由于 Windows 的 telnet 是 GBK 编码的，而 Linux 下使用 UTF-8 编码，你在 telnet 下的 Vim 中就会乱码。此时有两种消除乱码的方式：一是把 Vim 的 encoding 改为 gbk，另一种方法是保持 encoding 为 utf-8，把 termencoding 改为 gbk，让 Vim 在显示的时候转码。显然，使用前一种方法时，如果遇到编辑的文件中含有 GBK 无法表示的字符时，这些字符就会丢失。但如果使用后一种方法，虽然由于终端所限，这些字符无法显示，但在编辑过程中这些字符是不会丢失的。</p>
<p>对于图形界面下的 GVim，它的显示不依赖 TERM，因此 termencoding 对于它没有意义。在 GTK2 下的 GVim 中，termencoding 永远是 utf-8，并且不能修改。而 Windows 下的 GVim 则忽略 termencoding 的存在。</p>
<h3 id="3-fileencoding"><a href="#3-fileencoding" class="headerlink" title="3. fileencoding"></a>3. fileencoding</h3><p>当 Vim 从磁盘上读取文件的时候，会对文件的编码进行探测。如果文件的编码方式和 Vim 的内部编码方式不同，Vim 就会对编码进行转换。转换完毕后，Vim 会将 fileencoding 选项设置为文件的编码。当 Vim 存盘的时候，如果 encoding 和 fileencoding 不一样，Vim 就会进行编码转换。因此，通过打开文件后设置 fileencoding，我们可以将文件由一种编码转换为另一种编码。但是，由前面的介绍可以看出，fileencoding 是在打开文件的时候，由 Vim 进行探测后自动设置的。因此，如果出现乱码，我们无法通过在打开文件后重新设置 fileencoding 来纠正乱码。</p>
<h3 id="4-fileencodings"><a href="#4-fileencodings" class="headerlink" title="4. fileencodings"></a>4. fileencodings</h3><p>编码的自动识别是通过设置 fileencodings 实现的，注意是复数形式。fileencodings 是一个用逗号分隔的列表，列表中的每一项是一种编码的名称。当我们打开文件的时候，VIM 按顺序使用 fileencodings 中的编码进行尝试解码，如果成功的话，就使用该编码方式进行解码，并将 fileencoding 设置为这个值，如果失败的话，就继续试验下一个编码。</p>
<p>因此，我们在设置 fileencodings 的时候，一定要把要求严格的、当文件不是这个编码的时候更容易出现解码失败的编码方式放在前面，把宽松的编码方式放在后面。</p>
<p>例如，latin1 是一种非常宽松的编码方式，任何一种编码方式得到的文本，用 latin1 进行解码，都不会发生解码失败——当然，解码得到的结果自然也就是理所当然的“乱码”。因此，如果你把 latin1 放到了 fileencodings 的第一位的话，打开任何中文文件都是乱码也就是理所当然的了。</p>
<p>以下是滇狐推荐的一个 fileencodings 设置：</p>
<pre><code class="language-bash">
set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1
</code></pre>

<p>其中，ucs-bom 是一种非常严格的编码，非该编码的文件几乎没有可能被误判为 ucs-bom，因此放在第一位。</p>
<p>utf-8 也相当严格，除了很短的文件外(例如许多人津津乐道的 GBK 编码的“联通”被误判为 UTF-8 编码的经典错误)，现实生活中一般文件是几乎不可能被误判的，因此放在第二位。</p>
<p>如果编码被误判了，解码后的结果就无法被人类识别，于是我们就说，这个文件乱码了。此时，如果你知道这个文件的正确编码的话，可以在打开文件的时候使用 ++enc=encoding 的方式来打开文件，如：</p>
<pre><code class="language-bash">
:e ++enc=utf-8 myfile.txt
</code></pre>

<h3 id="5-fencview"><a href="#5-fencview" class="headerlink" title="5. fencview"></a>5. fencview</h3><p>根据前面的介绍，我们知道，通过 Vim 内置的编码识别机制，识别率是很低的，尤其是对于简体中文 (GBK/GB18030)、繁体中文 (Big5)、日文 (euc-jp) 和韩文 (euc-kr) 之间的识别。而对于普通用户而言，肉眼看出一个文件的编码方式也是很不现实的事情。因此，滇狐强烈推荐水木社区的 mbbill 开发的 fencview 插件。该插件使用词频统计的方式识别编码，正确率非常高。点击<a href="http://www.vim.org/scripts/script.php?script_id=1708" target="_blank" rel="external">这里</a>下载。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h2><p><a href="http://edyfox.codecarver.org/html/vim_fileencodings_detection.html" target="_blank" rel="external">http://edyfox.codecarver.org/html/vim_fileencodings_detection.html</a></p>
<p>–EOF–</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/TCP-IP-basics-3/" itemprop="url">
                  TCP/IP基础知识(3)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-28T13:58:38+08:00" content="2015-03-28">
              2015-03-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/TCP-IP-basics-3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="TCP-IP-basics-3/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/TCP-IP-basics-3/" class="leancloud_visitors" data-flag-title="TCP/IP基础知识(3)">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="TCP-IP体系结构之TCP协议"><a href="#TCP-IP体系结构之TCP协议" class="headerlink" title="TCP/IP体系结构之TCP协议"></a>TCP/IP体系结构之TCP协议</h1><hr>
<h2 id="1-TCP协议连接：建立、管理和终止"><a href="#1-TCP协议连接：建立、管理和终止" class="headerlink" title="1. TCP协议连接：建立、管理和终止"></a>1. TCP协议连接：建立、管理和终止</h2><p>TCP是面向连接的协议，在数据传送开始前必须先建立连接，一旦建立了连接，必须对其进行管理。待所有数据都传送完毕后，可以终止连接。</p>
<p>一个连接在其生存期内要经过一系列的状态变迁。在接收到某些事件时，连接可从一个状态前进到另一个状态。这些事件可能来自用户调用（像OPEN、SEND、RECEIVE、CLOSE、ABORT、STATUS），进入的报文段（带有激活的控制位，如SYN、FIN、ACK、RST）以及超时。</p>
<p>由于TCP的多连接特性，每个连接由一对套接字标识。建立、管理和终止连接的过程必须对每个连接独立进行。</p>
<p>在建立连接时要创建一个特殊的数据结构，以保持每个连接的特有数据。这个数据结构被称为运输控制块（TCB）。它包含如套接字对、流入/流出数据缓冲区的指针、滑动窗口系统跟踪发送/接收数据的变量等。</p>
<p>在连接报文中使用控制位。连接请求报文由一个SYN位置1的报文段组成，终止请求报文的FIN位置1，确认报文的ACK位置1。</p>
<h3 id="TCP连接状态"><a href="#TCP连接状态" class="headerlink" title="TCP连接状态"></a>TCP连接状态</h3><ul>
<li><strong>CLOSED</strong>:代表没有任何连接的初始状态。</li>
<li><strong>LISTEN</strong>:代表服务器在等待来自任何客户的连接请求。</li>
<li><strong>SYN-SENT</strong>:代表客户在发送了一个连接请求后等待服务器的确认和SYN报文。</li>
<li><strong>SYN-RECEIVED</strong>:代表服务器在接收到客户请求和发送完确认报文及自己向客户的请求后等待客户的确认。</li>
<li><strong>ESTABLISHED</strong>:代表打开了一个连接，在该状态可以进行数据发送。</li>
<li><strong>FIN-WAIT1</strong>:代表正在等待对已发送的终止请求的确认。</li>
<li><strong>FIN-WAIT2</strong>:代表设备在已经发送了终止请求并且收到了确认报文的情况下，正在等待来自另一设备的终止请求。</li>
<li><strong>CLOSING</strong>:代表同时关闭的情况。设备发送了一个终止请求，在接收到确认之前，收到了来自另一设备的终止请求。</li>
<li><strong>TIME-WAIT</strong>:代表正在等待超时，以确保远端设备接收到对其终止请求的确认。</li>
<li><strong>CLOSE-WAIT</strong>:代表正在等待来自应用的终止请求。</li>
<li><strong>LAST-ACK</strong>:代表正在等待对其已发送的终止请求的确认。</li>
</ul>
<h3 id="TCP连接生命周期状态图"><a href="#TCP连接生命周期状态图" class="headerlink" title="TCP连接生命周期状态图"></a>TCP连接生命周期状态图</h3><p><a class="cotent-img" href="/uploads/2015/3/tcpip_tcp连接生命周期状态图.png"><br>    <img src="/uploads/2015/3/tcpip_tcp连接生命周期状态图.png" alt="tcpip_tcp连接生命周期状态图" width="680"><br></a></p>
<h3 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h3><p><a class="cotent-img" href="/uploads/2015/3/tcpip_tcp连接建立.png"><br>    <img src="/uploads/2015/3/tcpip_tcp连接建立.png" alt="tcpip_tcp连接建立" width="680"><br></a></p>
<p>连接建立过程有3个目标：</p>
<ul>
<li>启动通信：客户通过发送SYN报文来发起连接请求，该报文由服务器确认。服务器也发送一个SYN报文，该报文由客户确认。</li>
<li>序号同步：每个设备都将自己第一次发送要使用的初始序号通知对方。</li>
<li>TCP选项参数交换：设备之间交换在TCP连接期间要使用的一些TCP选项。 </li>
</ul>
<p><a class="cotent-img" href="/uploads/2015/3/tcpip_tcp连接建立2.png"><br>    <img src="/uploads/2015/3/tcpip_tcp连接建立2.png" alt="tcpip_tcp连接建立2" width="680"><br></a></p>
<h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><p>一旦连接建立，两个设备即可开始互相传送数据。如果连接建立期间出现了问题，TCP连接管理功能必须负责。<br>连接的两个设备将一直保持在建立状态，直到以下条件之一发生：</p>
<ul>
<li>连接终止：一个设备发送了终止请求报文。</li>
<li>连接中断：出现了某些问题，使连接被中断。</li>
</ul>
<h4 id="半连接处理："><a href="#半连接处理：" class="headerlink" title="半连接处理："></a>半连接处理：</h4><p>一旦出现问题的设备恢复到正常工作状态，它可以使用一种特殊的复位功能进行复位操作，以便重新建立连接。<br>连接复位功能由一个首部的控制位字段中RST位置1的报文段构成。</p>
<p>若复位有效，依设备接收复位报文时所处的状态，可以采取下面的动作：</p>
<ul>
<li>接收者处于LISTEN状态，则复位被忽略。</li>
<li>接收者处于SYN-RECEIVED状态，并在此之前处于LISTEN状态，则接收者返回到LISTEN状态。</li>
<li>接收者处在任何其他状态，它将放弃连接，回到CLOSE状态</li>
</ul>
<h3 id="TCP连接终止"><a href="#TCP连接终止" class="headerlink" title="TCP连接终止"></a>TCP连接终止</h3><p><a class="cotent-img" href="/uploads/2015/3/tcpip_tcp连接终止.png"><br>    <img src="/uploads/2015/3/tcpip_tcp连接终止.png" alt="tcpip_tcp连接终止" width="680"><br></a></p>
<hr>
<h2 id="2-TCP可靠性和流控制"><a href="#2-TCP可靠性和流控制" class="headerlink" title="2. TCP可靠性和流控制"></a>2. TCP可靠性和流控制</h2><p>TCP是一种提供可靠数据运输的运输协议，但它使用的下层协议是本质上不可靠的网际协议。因此，TCP必须提供将不可靠的运输转化为可靠数据运输的机制。</p>
<p>原则上，提供可靠性所需要的机制应基于对每个发送报文的确认。</p>
<h3 id="肯定确认重传（PAR）机制"><a href="#肯定确认重传（PAR）机制" class="headerlink" title="肯定确认重传（PAR）机制"></a>肯定确认重传（PAR）机制</h3><p><a class="cotent-img" href="/uploads/2015/3/tcpip_肯定确认重传机制.png"><br>    <img src="/uploads/2015/3/tcpip_肯定确认重传机制.png" alt="tcpip_肯定确认重传机制" width="680"><br></a></p>
<h3 id="改进的PAR机制"><a href="#改进的PAR机制" class="headerlink" title="改进的PAR机制"></a>改进的PAR机制</h3><p><a class="cotent-img" href="/uploads/2015/3/tcpip_改进的PAR机制.png"><br>    <img src="/uploads/2015/3/tcpip_改进的PAR机制.png" alt="tcpip_改进的PAR机制" width="680"><br></a></p>
<h3 id="流控制功能"><a href="#流控制功能" class="headerlink" title="流控制功能"></a>流控制功能</h3><p><a class="cotent-img" href="/uploads/2015/3/tcpip_tcp流控制功能.png"><br>    <img src="/uploads/2015/3/tcpip_tcp流控制功能.png" alt="tcpip_tcp流控制功能" width="680"><br></a></p>
<h3 id="TCP滑动窗口确认系统"><a href="#TCP滑动窗口确认系统" class="headerlink" title="TCP滑动窗口确认系统"></a>TCP滑动窗口确认系统</h3><p>滑动窗口确认系统是TCP所使用的提供可靠运输和流控制的机制。</p>
<p>它与改进的PAR之间存在如下区别：</p>
<ul>
<li>由于TCP是一个面向流的协议，所以滑动窗口中每个“被标识的报文”都被一个字节序列代替。</li>
<li>在滑动窗口中接收设备用最后一个数据字节序号加1来确认每个报文段，表示这必须是发送设备能发送的下一个报文段的序号。</li>
</ul>
<p>TCP连接两端的每个设备都必须实现滑动窗口，以跟踪已发送的字节和已接收的字节。这样就存在两种滑动窗口：发送和接收窗口</p>
<h4 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h4><p><a class="cotent-img" href="/uploads/2015/3/tcpip_tcp发送窗口.png"><br>    <img src="/uploads/2015/3/tcpip_tcp发送窗口.png" alt="tcpip_tcp发送窗口" width="680"><br></a></p>
<h4 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h4><p><a class="cotent-img" href="/uploads/2015/3/tcpip_tcp接收窗口.png"><br>    <img src="/uploads/2015/3/tcpip_tcp接收窗口.png" alt="tcpip_tcp接收窗口" width="680"><br></a></p>
<h4 id="滑动窗口指针"><a href="#滑动窗口指针" class="headerlink" title="滑动窗口指针"></a>滑动窗口指针</h4><p>发送窗口用3个指针工作，这些指针将字节流分成4个区域。<br>SND.UNA:发送未确认指针。为已发送但尚未确认的第1个数据字节的序号。<br>SND.NXT:发送下一个指针。为要发送给另一设备的第1个数据字节的序号。<br>SND.WND:发送窗口指针。为发送窗口大小。</p>
<p>接收窗口用2个指针工作，这些指针将字节流分成3个区域。<br>RCV.NXT:接收下一个指针。为希望从另一设备接收的第1个数据字节序号。<br>RCV.WND:接收窗口指针。为接收窗口大小，这是TCP报文段首部窗口字段的值，用于通知发送者接收设备还能接受多少数据，实现流控制机制。</p>
<p>TCP报文段首部中的序号、确认号和窗口字段用于更新这些指针。</p>
<h3 id="TCP报文重发机制"><a href="#TCP报文重发机制" class="headerlink" title="TCP报文重发机制"></a>TCP报文重发机制</h3><p>重传机制包括下面的过程：</p>
<ul>
<li>对每个发送的报文段，启动一个为它分配的定时器，并将该报文段的副本保存到重发队列中。</li>
<li>如果在相应的定时器溢出之前收到了该报文段的确认，则将该报文从重发队列中删除。</li>
<li>如果定时器溢出时确认报文段还未到达，则该报文段被自动重发。其定时器重新启动，报文段仍保存在重发队列中，直到接收到一次成功的确认。</li>
<li>如果在进行了多次连续的重发后仍然没有收到确认报文段，可认为在网络的某处存在持久性的问题而终止连接，并向应用报告。</li>
</ul>
<h3 id="选择性确认SACK"><a href="#选择性确认SACK" class="headerlink" title="选择性确认SACK"></a>选择性确认SACK</h3><p>该功能用于在接收到不连续的报文段时，向发送者报告那些不能被累加性确认系统确认的报文段。这样一来，发送者就有必要的信息来决定再重发一个报文段时对后续的已发报文采取何种策略。</p>
<p>该功能需在建立连接的SYN报文中选择<strong>SACK选项</strong>(类型为4)来使用。而后接收者可用一个报文段的TCP首部选项(类型为5)将所接收的不连续数据块信息通知发送者。</p>
<h3 id="“糊涂”窗口综合症"><a href="#“糊涂”窗口综合症" class="headerlink" title="“糊涂”窗口综合症"></a>“糊涂”窗口综合症</h3><p>被关闭的窗口有可能被这样打开：服务器仍然很忙，但它可以传送一个字节给应用。一旦这样，服务器就会发送一个窗口字段值为1的报文给客户。客户会重新打开其发<br>送窗口，窗口大小为1字节。</p>
<p>这样就会产生一种效率极低的数据传输方式，此异常情况被称为<strong>“糊涂窗口”综合症(SWS)</strong>。它的出现是因为滑动窗口系统没有为发送的报文段规定最小值。</p>
<h3 id="TCP常见应用"><a href="#TCP常见应用" class="headerlink" title="TCP常见应用"></a>TCP常见应用</h3><p>协议–说明–服务器端口：<br>FTP–用于传送文件–20/21<br>TELNET–允许用户使用远程设备–23<br>SMTP–用于发送电子邮件报文–25<br>DNS–交换域名解析的请求/应答报文–53<br>HTTP–用于提取万维网中的文档–80<br>POP3–用于提取电子邮件报文–110<br>NNTP–用于传送新闻组报文–119<br>IMAP–另一种邮件提取协议–143<br>IRC–允许用户聊天的一种交互协议–194</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>运输层为TCP/IP栈中的应用层提供“主机到主机”的通信服务。有两种版本的运输服务：用户数据包协议UDP和运输控制协议TCP。</li>
<li>运输层提供进程寻址，允许多个应用共享同一个IP地址。为此，每个进程备份配一个不同的端口号。为服务器应用进程分配知名端口号0~1023之一，客户应用进程启动时都会被分配一个临时端口号。</li>
<li>套接字是通信端标识符，它由IP地址和端口号确定。</li>
<li>UDP是一种简单、高效、快速的运输协议，但它是不可靠的。TCP是一种功能完备的运输协议，它面向连接，提供流控制和确认运输及重传机制。</li>
<li>由于TCP是一种面向连接的协议，所以它必须有建立、管理和终止连接的过程。SYN报文用与请求建立连接，在这一阶段，TCB被创建，初始序号和一些TCP选项参数的交换也发生在该阶段。连接建立阶段通过“3次握手”完成。当一个或两个设备决定关闭连接时，执行连接终止阶段。每个设备必须发送FIN报文并接收其确认，此后，连接被认为已经关闭。</li>
<li>滑动窗口确认系统为TCP运输提供可靠性和流控制。TCP连接两端的每个设备都必须为其发送和接收实现滑动窗口。一个设备的发送窗口即为另一设备的接收窗口。</li>
<li>重传机制跟踪已发送的报文段并在需要时重传这些报文段。对每个已发送的报文段，都要启动一个定时器并将该报文段的副本放入一个重传队列中。若在定时器溢出之前收到了确认，则该报文段被从重传队列中删除，否则，重启定时器并重发该报文段。</li>
<li>选择性确认SACK选项允许接收者将已接收的非连续报文段的信息通知发送者，这样一来发送者就能正确决定哪个报文段应被重传。</li>
<li>滑动窗口并不只是能限制发送者发送的数据量，它还能降低发送者发送数据的速率。这是通过调整滑动窗口尺寸来实现的。</li>
</ul>
<p>–EOF–</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/TCP-IP-basics-2/" itemprop="url">
                  TCP/IP基础知识(2)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-28T12:05:19+08:00" content="2015-03-28">
              2015-03-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/TCP-IP-basics-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="TCP-IP-basics-2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/TCP-IP-basics-2/" class="leancloud_visitors" data-flag-title="TCP/IP基础知识(2)">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="TCP-IP体系结构之TCP和UDP协议"><a href="#TCP-IP体系结构之TCP和UDP协议" class="headerlink" title="TCP/IP体系结构之TCP和UDP协议"></a>TCP/IP体系结构之TCP和UDP协议</h1><hr>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul>
<li>为了改善网际层数据报交付不可靠的情况，一种方法是对接收的数据报进行确认。但是IP层不提供这种支持，因为有些应用不需要。</li>
<li>运输层提供针对不同需求的服务：较高成本的面向连接的可靠运输服务及较简单的和更快速的不可靠运输服务。</li>
</ul>
<p><strong>运输控制协议</strong>(<strong>TCP</strong>)：是一个功能完备的运输协议，它面向连接，具有流控制、运输确认和重传机制。<br><strong>用户数据报协议</strong>(<strong>UDP</strong>)：是一个简单、高效和快速的运输协议，但它是不可靠的。</p>
<hr>
<h2 id="2-端口"><a href="#2-端口" class="headerlink" title="2. 端口"></a>2. 端口</h2><p>通常一个设备上运行不止一个应用，设备的IP地址为这些应用所共享。发送数据报的每个应用都具有相同的IP源地址，接收到的每个数据报都有相同的目的IP地址。为了使多个应用能使用TCP/IP栈，应用数据被运输层以复用和分用的方式进行运输。</p>
<p><a class="cotent-img" href="/uploads/2015/3/tcpip_分层复用.png"><br>    <img src="/uploads/2015/3/tcpip_分层复用.png" alt="tcpip_分层复用" width="680"><br></a></p>
<h3 id="端口地址"><a href="#端口地址" class="headerlink" title="端口地址"></a>端口地址</h3><p>为了区分某些应用，运输层为每个进程分配不同的端口。从应用接收的数据被运输层封装，在此加入源和目的端口。在接收端，网际层接收数据报，并将数据传递给运输层，运输层使用目的端口将报文传递给正确的应用。</p>
<ul>
<li>运输层的UDP和TCP协议为应用提供服务，端口地址16位，所以每种协议有65536个端口可用。</li>
<li>应用协议使用客户/服务器模型。启动通信的客户程序需要知道服务器应用程序的目的端口。服务器使用接收到的报文中的源端口获知客户端口。</li>
</ul>
<p><a class="cotent-img" href="/uploads/2015/3/tcpip_端口应用.png"><br>    <img src="/uploads/2015/3/tcpip_端口应用.png" alt="tcpip_端口应用" width="680"><br></a></p>
<p>TCP和UDP端口号分配可分成3个范围：</p>
<ul>
<li>知名端口号(0~1023)：保留给通用的TCP/IP应用；</li>
<li>注册端口号(1024~49151)：其它应用可以注册使用的端口号；</li>
<li>动态/私有端口号(49152~65535)：不被管理，可以用于任何目的，可以被任何机构使用。</li>
</ul>
<p>完全的端口号分配表由IANA维护，可以在<a href="http://www.iana.org/assignments/port-numbers" target="_blank" rel="external">[该网站]</a>查询到。</p>
<p>下图列举了常用的知名端口：<br><a class="cotent-img" href="/uploads/2015/3/tcpip_知名端口.png"><br>    <img src="/uploads/2015/3/tcpip_知名端口.png" alt="tcpip_知名端口" width="680"><br></a></p>
<h3 id="TCP-IP套接字"><a href="#TCP-IP套接字" class="headerlink" title="TCP/IP套接字"></a>TCP/IP套接字</h3><ul>
<li>套接字是一个通信端标识符，由IP地址和端口号决定；</li>
<li>套接字与TCP/IP应用程序接口(API)相关联，每个API功能都需要一个套接字作为标识符；</li>
<li>有两种类型的套接字：<strong>流</strong>（TCP）和<strong>数据报</strong>（UDP）；</li>
<li>两个设备之间交换数据可以描述为报文从某一设备上的套接字发送到另一设备上的套接字。两个套接字建立关联，标注为<br>$$ <200.136.112.75:2520,205.122.63.20:80> $$</200.136.112.75:2520,205.122.63.20:80></li>
<li>可以建立多个套接字，以允许几个应用共享同一个设备的IP地址。另外，在一个设备上可以存在多个关联，即一个设备可以同时与其它设备有多个连接。<br><a class="cotent-img" href="/uploads/2015/3/tcpip_套接字模型.png"><br>  <img src="/uploads/2015/3/tcpip_套接字模型.png" alt="tcpip_套接字模型" width="640"><br></a></li>
</ul>
<hr>
<h2 id="3-用户数据报协议（UDP）"><a href="#3-用户数据报协议（UDP）" class="headerlink" title="3. 用户数据报协议（UDP）"></a>3. 用户数据报协议（UDP）</h2><p>用户数据报协议(UDP)是为那些需要一种简单且快速的运输协议的应用而设计的。对这些应用来说，甚至可以不保证报文的交付和重复，或者重传也没有意义。</p>
<p>UDP只实现端口导址。提供了一个可选的效验和用于错误检测。其它工作都由网际协议完成。<br><a class="cotent-img" href="/uploads/2015/3/tcpip_udp报文格式.png"><br>    <img src="/uploads/2015/3/tcpip_udp报文格式.png" alt="tcpip_udp报文格式" width="680"><br></a></p>
<h3 id="UDP报文格式说明"><a href="#UDP报文格式说明" class="headerlink" title="UDP报文格式说明"></a>UDP报文格式说明</h3><ul>
<li><strong>源端口(2字节)</strong>：发送报文的应用进程的16位端口号。</li>
<li><strong>目的端口(2字节)</strong>：目的设备上的接收进程的16位端口号。</li>
<li><strong>长度(2字节)</strong>：整个UDP数据报的长度，包括首部和数据字段。</li>
<li><strong>校验和(2字节)</strong>：提供错误检测功能的16位校验和，可选项。</li>
<li><strong>数据(可变长度)</strong>：要发送的已封装应用报文。</li>
</ul>
<h3 id="基于UDP的应用"><a href="#基于UDP的应用" class="headerlink" title="基于UDP的应用"></a>基于UDP的应用</h3><ul>
<li>请求-应答应用</li>
<li>数据流应用</li>
</ul>
<p><a class="cotent-img" href="/uploads/2015/3/tcpip_udp应用.png"><br>    <img src="/uploads/2015/3/tcpip_udp应用.png" alt="tcpip_udp应用" width="680"><br></a></p>
<hr>
<h2 id="4-运输控制协议（TCP）"><a href="#4-运输控制协议（TCP）" class="headerlink" title="4. 运输控制协议（TCP）"></a>4. 运输控制协议（TCP）</h2><p>运输控制协议(TCP)是一种功能完备的面向连接的运输协议，具有流控制、运输确认和重传机制。</p>
<h3 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h3><ul>
<li><strong>面向连接</strong>: 在设备之间发生数据传送之前，必须先建立一个连接。</li>
<li><strong>多连接</strong>: 允许一个设备有多个连接打开而不会产生冲突。</li>
<li><strong>全双工</strong>: 一旦建立了连接，数据可以在两个方向传送。</li>
<li><strong>面向流</strong>: 允许应用已连续字节流的方式发送数据，TCP必须将数据打包成块后再将其交给IP。</li>
<li><strong>非结构化数据</strong>: 将以字节流的形式传送的数据分割成原始的数据报。</li>
<li><strong>可靠</strong>: TCP保证所有发送的数据都能到达其目的地。</li>
<li><strong>确认</strong>: TCP发送的每个报文都需要被接收方确认。</li>
<li><strong>流控制</strong>: 当某设备以某个数率发送数据而接收设备来不及处理时，TCP提供一种机制，使接收设备能通知发送设备降低发送数率或停止发送。</li>
<li><strong>进程编址</strong>: 对于共享同一个IP地址的不同应用，TCP提供了一种标识每个应用和以复用方式将数据传给IP层的方法。在接收端，TCP以分用的方式将数据传给目的应用。这一编址机制由端口号来实现。</li>
</ul>
<h3 id="TCP报文单元"><a href="#TCP报文单元" class="headerlink" title="TCP报文单元"></a>TCP报文单元</h3><ul>
<li>TCP提供字节流传送数据的方式，应用不需要关心如何打包数据才能将其传送给运输层。</li>
<li>虽然TCP是面向流的，但其下面的IP层却不是，所以TCP必须将接收到的流分割成合适的数据块，这些数据块被封装成“报文段”。</li>
<li>TCP以流的形式接受来自应用层的数据，这一现实的直接含义是：使用TCP的应用所接收的数据是非结构化的。</li>
</ul>
<p><a class="cotent-img" href="/uploads/2015/3/tcpip_tcp报文段格式.png"><br>    <img src="/uploads/2015/3/tcpip_tcp报文段格式.png" alt="tcpip_tcp报文段格式" width="680"><br></a></p>
<h3 id="TCP报文格式说明"><a href="#TCP报文格式说明" class="headerlink" title="TCP报文格式说明"></a>TCP报文格式说明</h3><ul>
<li><strong>源端口</strong>（2字节）：源设备上发送报文段的进程的16位端口号。一般来说，对于请求报文它是一个客户进程，对于应答报文它是一个服务器进程。</li>
<li><strong>目的端口</strong>（2字节）：目的设备上接收进程的16位端口号。一般来说，对于请求报文它是一个服务器进程，对于应答报文它是一个客户进程。</li>
<li><strong>序号</strong>（4字节）：由滑动窗口确认系统使用，作为报文段中的一个字节的序号。在SYN位置1的情况下（连接请求报文），它指示初始序号（ISN）。</li>
<li><strong>确认号</strong>（4字节）：若ACK位置1，该字段有效并包含设备用于对接收到的数据进行确认的确认号。</li>
<li><strong>数据偏移</strong>（4字节）：指示数据的开始位置与TCP报文段的开始处有多少个32位字的偏移量。</li>
<li><strong>保留</strong>（6位）：填充0。</li>
<li><strong>控制位</strong>（6位）：用于控制信息。<ul>
<li><strong>URG</strong>（紧急位，1位）：若置1，表示该报文段包含紧急数据，由紧急指针字段指示其位置。</li>
<li><strong>ACK</strong>（确认位，1位）：若置1，表示该报文段是一个确认报文，并且确认号字段有效。</li>
<li><strong>PSH</strong>（推送位，1位）：若置1，表示该报文段中的数据必须被立即发送并被推送给接收设备上的应用。否则，该数据将要等到更多的数据传给TCP，达到报文段长度后才被发送。</li>
<li><strong>RST</strong>（复位位，1位）：若置1，表示发送者检测到一个问题并希望对连接进行复位。</li>
<li><strong>SYN</strong>（同步位，1位）：若置1，表示该报文段请求对序号同步并建立一个连接。序号字段包含发送者用于该连接的初始序号（ISN）。</li>
<li><strong>FIN</strong>（结束位，1位）：若置1，表示该报文段的发送者请求关闭连接。</li>
</ul>
</li>
<li><strong>窗口</strong>（2字节）：用于流控制，指示该报文段的发送者在给定时间内能从其他设备接收的字节数。</li>
<li><strong>校验和</strong>（2字节）：16位校验和。</li>
<li><strong>紧急指针</strong>（2字节）：若URG位置1，该字段包含紧急数据后面的“正常”数据第一个字节的序号。</li>
<li><strong>选项</strong>（可变长度）：一组选择项。</li>
<li><strong>填充</strong>（可变长度）：若选项字段的长度不是32位的整数倍，则要用足够的0来填充首部。</li>
<li><strong>数据</strong>（可变长度）：报文段中要发送的数据字节。</li>
</ul>
<h3 id="报文段首部选项"><a href="#报文段首部选项" class="headerlink" title="报文段首部选项"></a>报文段首部选项</h3><ul>
<li>选项类型(1字节)-指定选项的类型；</li>
<li>选项长度(1字节)-以字节为单位的整个选项的长度；</li>
<li>选项数据(可变长度)-选项中使用的数据。</li>
</ul>
<p>选项字段有两种可能的格式：</p>
<p><a class="cotent-img" href="/uploads/2015/3/tcpip_tcp报文段首部选项.png"><br>    <img src="/uploads/2015/3/tcpip_tcp报文段首部选项.png" alt="tcpip_tcp报文段首部选项" width="680"><br></a></p>
<h3 id="常用的TCP选项"><a href="#常用的TCP选项" class="headerlink" title="常用的TCP选项"></a>常用的TCP选项</h3><p><a class="cotent-img" href="/uploads/2015/3/tcpip_常用TCP选项.png"><br>    <img src="/uploads/2015/3/tcpip_常用TCP选项.png" alt="tcpip_常用TCP选项" width="680"><br></a></p>
<h3 id="PUSH功能"><a href="#PUSH功能" class="headerlink" title="PUSH功能"></a>PUSH功能</h3><p>数据从应用传到TCP层时，首先被缓存，然后构建长度适宜的报文段，并将其发送到IP层，报文段长度必须足够大。如果传输的数据很少，构不成合适的报文段，则数据一直要保存在缓冲区中。在有些应用中，，这种做法会产生负面影响。</p>
<p>为解决这一问题，应用传递的数据需要立即发送时，启用“PUSH”功能。TCP构建一个报文段，将其PSH控制位置1并发送出去。接收端收到报文并看到PSH位激活时，必须无延迟的将数据传给应用。</p>
<h3 id="URGENT功能"><a href="#URGENT功能" class="headerlink" title="URGENT功能"></a>URGENT功能</h3><p>所有数据在重要性方面被平等对待，但有些情况下，某些重要紧急的信息必须在不等待其对应次序的情况下发送给接受者。</p>
<p>当一个应用调用“URGENT”功能时，TCP会构建一个能将其立即发送出去的报文段。该报文段中的URG控制位被置1。该报文段也可以与正常数据合在一起，由TCP首部紧急指针字段指示紧急数据的结束。</p>
<hr>
<p>–EOF–</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/TCP-IP-basics-1/" itemprop="url">
                  TCP/IP基础知识(1)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-26T22:10:04+08:00" content="2015-03-26">
              2015-03-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/TCP-IP-basics-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="TCP-IP-basics-1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/TCP-IP-basics-1/" class="leancloud_visitors" data-flag-title="TCP/IP基础知识(1)">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="TCPIP栈体系结构"><a href="#TCPIP栈体系结构" class="headerlink" title="TCPIP栈体系结构"></a>TCPIP栈体系结构</h1><hr>
<h2 id="TCP-IP采用四层架构"><a href="#TCP-IP采用四层架构" class="headerlink" title="TCP/IP采用四层架构"></a>TCP/IP采用四层架构</h2><p><a href="/uploads/2015/3/tcpip_四层架构.png"><br>    <img src="/uploads/2015/3/tcpip_四层架构.png" alt="tcpip_四层架构" width="700"><br></a></p>
<ul>
<li><strong>网络接口层</strong>：也称链路层，是较高协议层与局域网接口的地方。</li>
<li><strong>网际层</strong>：负责网间寻址、数据封装、路由选择、分片、错误处理和诊断。可在该层运行IP协议、ICMP协议和几个路由协议。</li>
<li><strong>运输层</strong>：负责在网际设备之间运输数据。该层构成端到端的通信。在该层中不同的进程被分配具体的源和目的地址（端口号）。</li>
<li><strong>应用层</strong>：用户的应用使用运行在该层的协议。</li>
</ul>
<hr>
<h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h2><p><a href="/uploads/2015/3/tcpip_协议族1.png"><br>    <img src="/uploads/2015/3/tcpip_协议族1.png" alt="tcpip_协议族1" width="680"><br></a><br><a href="/uploads/2015/3/tcpip_协议族2.png"><br>    <img src="/uploads/2015/3/tcpip_协议族2.png" alt="tcpip_协议族2" width="680"><br></a><br><a href="/uploads/2015/3/tcpip_协议族3.png"><br>    <img src="/uploads/2015/3/tcpip_协议族3.png" alt="tcpip_协议族3" width="680"><br></a></p>
<p>##TCP/IP协议相关性</p>
<p><a href="/uploads/2015/3/tcpip_协议相关性.png"><br>    <img src="/uploads/2015/3/tcpip_协议相关性.png" alt="tcpip_协议相关性" width="680"><br></a></p>
<hr>
<h1 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h1><h2 id="IEEE-802模型"><a href="#IEEE-802模型" class="headerlink" title="IEEE 802模型"></a>IEEE 802模型</h2><p>IEEE802模型与ISO模型的两个低层相关：物理层和数据链路层。</p>
<p>802模型将数据链路层分成3个子层：逻辑链路控制层（LLC802.2）、 桥接层（802.1）和介质访问控制层（MAC）</p>
<p><a href="/uploads/2015/3/tcpip_802模型.png"><br>    <img src="/uploads/2015/3/tcpip_802模型.png" alt="tcpip_802模型" width="680"><br></a></p>
<hr>
<h1 id="网际层IP和ICMP"><a href="#网际层IP和ICMP" class="headerlink" title="网际层IP和ICMP"></a>网际层IP和ICMP</h1><h2 id="网际协议IPv4"><a href="#网际协议IPv4" class="headerlink" title="网际协议IPv4"></a>网际协议IPv4</h2><p>网际协议是TCP/IP的重要组成，它位于网际层，为运输层(UDP、TCP) 提供服务，并从网络接入层(LAN驱动程序、SLIP 、PPP)请求服务。</p>
<p>##IPV4数据报格式</p>
<p><a href="/uploads/2015/3/tcpip_数据报格式.PNG"><br>    <img src="/uploads/2015/3/tcpip_数据报格式.PNG" alt="tcpip_数据报格式" width="680"><br></a></p>
<p>版本(4位)：表示IP的版本，对于IPv4，其值为0x04。<br>首部长度(4位) ：全部首部，包括选项和填充的长度，以字长32位为单位。如果没有首部选项，该字段的值为0x05(20字节，5个字)。<br>服务类型(1字节)：指示所希望的服务质量。<br>优先(位0~2) -该值越大，数据报相对其它数据报的优先级越高。<br>时延(位3) -若需要较低的时延，须将该位置1。<br>吞吐量(位4) -若需要较高的吞吐量，须将该位置1。<br>可靠性(位5) -若需要较高的可靠性，须将该位置1。<br><strong>总长度(2字节)</strong>：指示IP数据报的总长度(最大值65535字节)。<br>标识(2字节)：在分片中使用，同一报文的所有分片具有相同的标识号。因为不同报文的分片可能混杂在一起接收，所以该标识号能帮助将来自同一原始报文的分片组装到一起。<br>标志(3位)：在分片中使用。<br>不分片DF(位1) -指示该数据包信息字段不能分片。<br>还有分片MF(位2) -该位置1，指示后面还有分片。该位置0，说明该数据报是最后一个分片或数据报未分片。<br>分片偏移(13位)：指示该分片在原始报文中的位置。偏移以8字节为单位，所以需要将其值乘以8来得到正确位置。<br>生存时间(1字节)：用于防止数据报无限期的在路由之间流动。数据报每经过一个路由器该值减1。若为0，数据报被丢弃。<br>协议(1字节)：指示在净荷中承载的上层协议。<br>首部校验和(2字节)：对IP首部计算的16位校验和。当接收到数据报时，要重新计算校验和并与该字段比对。若两个结果不一样则数据报被丢弃。<br><strong>源地址(4字节)</strong>：创建数据报的设备的32位IP地址。<br><strong>目的地址(4字节)</strong>：数据报的预期接收设备的32位IP地址。<br>选项(可变长度)：0或多个选项。<br>填充(可变长度)：如果包含选项，则选项字段尺寸必须是32位的整数倍，否则必须使用填充字节。<br>数据(可变长度)：要发送的数据(或原始数据报被分片后的一个分片)。</p>
<h2 id="IP编址"><a href="#IP编址" class="headerlink" title="IP编址"></a>IP编址</h2><p><a href="/uploads/2015/3/tcpip_ip地址表示法.PNG"><br>    <img src="/uploads/2015/3/tcpip_ip地址表示法.PNG" alt="tcpip_ip地址表示法" width="680"><br></a></p>
<h3 id="设备的IP地址"><a href="#设备的IP地址" class="headerlink" title="设备的IP地址"></a>设备的IP地址</h3><p>每个设备都必须有一个唯一的IP地址。但是这并不意味着一个设备只能有一个IP地址。比如路由器。即每个网络接口有一个IP地址。<br>主机也可能不止一个IP地址，即多址主机。可能有更多对统一网络或不同网络的接口，如果运行合适的软件，可以起到路由器作用。</p>
<p><a href="/uploads/2015/3/tcpip_设备ip地址.PNG"><br>    <img src="/uploads/2015/3/tcpip_设备ip地址.PNG" alt="tcpip_设备ip地址" width="680"><br></a></p>
<h3 id="IP地址结构"><a href="#IP地址结构" class="headerlink" title="IP地址结构"></a>IP地址结构</h3><p>由于互联网由互相连接在一起的网络组成，而且每个网络都连接了若干主机或设备，所以将IP地址分成网络ID和主机ID两部分是很自然的。这种结构便于路由器工作。<br>32位IP地址中用多少位来表示网络ID和主机ID取决于所使用的IP编址机制。</p>
<p><a href="/uploads/2015/3/tcpip_ip地址结构.PNG"><br>    <img src="/uploads/2015/3/tcpip_ip地址结构.PNG" alt="tcpip_ip地址结构" width="680"><br></a></p>
<h3 id="IP分类编址"><a href="#IP分类编址" class="headerlink" title="IP分类编址"></a>IP分类编址</h3><p>根据网络的规模(主机数)将网络分成3个主要的类</p>
<p><a href="/uploads/2015/3/tcpip_分类编址.PNG"><br>    <img src="/uploads/2015/3/tcpip_分类编址.PNG" alt="tcpip_分类编址" width="680"><br></a></p>
<p>由IP地址的第一字节可判断出该IP属于的地址类。</p>
<p><a href="/uploads/2015/3/tcpip_分类编址列表.PNG"><br>    <img src="/uploads/2015/3/tcpip_分类编址列表.PNG" alt="tcpip_分类编址列表" width="680"><br></a></p>
<h3 id="保留IP地址"><a href="#保留IP地址" class="headerlink" title="保留IP地址"></a>保留IP地址</h3><p>在三个主类所定义的IP地址中，有一些IP地址范围是不能使用的。保留作为下列用途：</p>
<ul>
<li><strong> [私网]</strong>这些IP地址不是可用于寻路的地址，在公网上不存在，路由器 会忽略它们。<br>A类：10.0.0.0~10.255.255.255<br>B类：169.254.0.0~169.254.255.255, 172.16.0.0~172.16.255.255<br>C类：192.168.0.0~192.168.255.255    </li>
<li><strong>[环回]</strong>这些IP地址作为环回测试用。实际上，当一个IP数据报被发送到环回地址时，该数据报不会被传到数据链路层并通过物理层发送出去，而是被环回到网际层的源地址。<br>这些地址是：127.0.0.0~127.255.255.255</li>
<li><strong>[其它用途]</strong>保留作为其它不同用途。如网络试验。</li>
</ul>
<h3 id="分类编址机制的问题"><a href="#分类编址机制的问题" class="headerlink" title="分类编址机制的问题"></a>分类编址机制的问题</h3><p>地址空间利用率不高；不适合大型网络。</p>
<h2 id="IP子网编址"><a href="#IP子网编址" class="headerlink" title="IP子网编址"></a>IP子网编址</h2><p>IP子网编址机制：为了适合大型网络，在IP地址的主机ID部分引入了一个新的机制。网络ID保持不变，主机ID被进一步分成几个子网，每个子网包含主机。</p>
<p><a href="/uploads/2015/3/tcpip_ip子网编址.PNG"><br>    <img src="/uploads/2015/3/tcpip_ip子网编址.PNG" alt="tcpip_ip子网编址" width="680"><br></a></p>
<h3 id="子网编址的结构"><a href="#子网编址的结构" class="headerlink" title="子网编址的结构"></a>子网编址的结构</h3><p>IP地址的主机ID被分成子网ID和主机ID。<br>子网ID和主机ID的位数取决于网络的组织。</p>
<p><a href="/uploads/2015/3/tcpip_子网编址结构1.PNG"><br>    <img src="/uploads/2015/3/tcpip_子网编址结构1.PNG" alt="tcpip_子网编址结构1" width="680"><br></a></p>
<h3 id="IP-掩码对"><a href="#IP-掩码对" class="headerlink" title="IP/掩码对"></a>IP/掩码对</h3><p>对于一个给定的IP地址，如何知道子网ID和主机ID有多少位呢？<br>为了知道子网ID和主机ID的分界线，必须辅以子网掩码。在子网掩码中，网络ID和子网ID的对应位全为1，主机ID的对应位全为0。</p>
<p><a href="/uploads/2015/3/tcpip_子网编址结构2.PNG"><br>    <img src="/uploads/2015/3/tcpip_子网编址结构2.PNG" alt="tcpip_子网编址结构2" width="680"><br></a></p>
<h3 id="变长子网掩码机制-VLSM"><a href="#变长子网掩码机制-VLSM" class="headerlink" title="变长子网掩码机制(VLSM)"></a>变长子网掩码机制(VLSM)</h3><p>子网编址的缺陷即是所有子网必须有相同的尺寸(最大主机数)。变长子网掩码是将网络地址空间拆分成几个不同尺寸的子网。</p>
<p><a href="/uploads/2015/3/tcpip_VLSM.PNG"><br>    <img src="/uploads/2015/3/tcpip_VLSM.PNG" alt="tcpip_VLSM" width="680"><br></a></p>
<p>VLSM实例如下所示：</p>
<p><a href="/uploads/2015/3/tcpip_VLSM实例.PNG"><br>    <img src="/uploads/2015/3/tcpip_VLSM实例.PNG" alt="tcpip_VLSM实例" width="680"><br></a></p>
<h3 id="无类别地址机制-CIDR"><a href="#无类别地址机制-CIDR" class="headerlink" title="无类别地址机制(CIDR)"></a>无类别地址机制(CIDR)</h3><p>分类编址机制不能适合不同规模网络的多样性，造成可用IP地址空间的匮乏。CIDR的思想是将子网技术应用于整个Internet。</p>
<h2 id="IP交付和路由"><a href="#IP交付和路由" class="headerlink" title="IP交付和路由"></a>IP交付和路由</h2><ul>
<li>数据报交付是IP层的主要任务。若两个主机位于同一个LAN中，则该报文由数据链路层在本地交付。称为直接交付。主机位于远程的不同网络中的交付情况称为间接交付。</li>
<li>路由器是完成间接交付的设备。</li>
<li>主机必须配置一个IP地址、一个子网掩码和一个默认网关。 </li>
</ul>
<p><a href="/uploads/2015/3/tcpip_路由表.PNG"><br>    <img src="/uploads/2015/3/tcpip_路由表.PNG" alt="tcpip_路由表" width="680"><br></a></p>
<h2 id="控制报文协议ICMP"><a href="#控制报文协议ICMP" class="headerlink" title="控制报文协议ICMP"></a>控制报文协议ICMP</h2><p>由于IP是不可靠的，需要一种反馈机制。ICMP协议为IP层通信提供一个维护、诊断和测试框架。<br>ICMP不用于交付信息；IP数据报用于交付信息。 </p>
<p><a class="cotent-img" href="/uploads/2015/3/tcpip_icmp报文格式.png"><br>    <img src="/uploads/2015/3/tcpip_icmp报文格式.png" alt="tcpip_icmp报文格式" width="680"><br></a></p>
<p>ICMP通过将信息封装在IP分组中，并设置报头的协议字段为1来发送信息。ICMP报文可以分为：</p>
<ul>
<li>差错报文</li>
<li>控制报文</li>
<li>请求应答报文</li>
</ul>
<p><a class="cotent-img" href="/uploads/2015/3/tcpip_icmp差错报文.png"><br>    <img src="/uploads/2015/3/tcpip_icmp差错报文.png" alt="tcpip_icmp差错报文" width="680"><br></a></p>
<p><a class="cotent-img" href="/uploads/2015/3/tcpip_icmp信息交换报文.png"><br>    <img src="/uploads/2015/3/tcpip_icmp信息交换报文.png" alt="tcpip_icmp信息交换报文" width="680"><br></a></p>
<h3 id="差错报文"><a href="#差错报文" class="headerlink" title="差错报文"></a>差错报文</h3><p>ICMP差错报文最根本的功能是提供差错报告，中间的路由器或目的端在处理IP报文时，如果发现错误，就向源端主机发送ICMP差错控制报文。主要包括：</p>
<ul>
<li>目的无法到达(Destination Unreachable),用于报告多种原因造成的IP报文无法到达的错误。</li>
<li>超时( Time Exceeded)。 当IP分组中的生存期TTL字段减到0或重装定时器（在收到分组的第一个段时设置）到期时发送超时分组。 </li>
<li>参数问题(Parameter Problem)报文用于报告IP报文头的错误。</li>
</ul>
<h3 id="控制报文"><a href="#控制报文" class="headerlink" title="控制报文"></a>控制报文</h3><p>ICMP的控制报文主要用于网络层的拥塞控制和路径控制。包括源抑制和重定向报文。</p>
<ul>
<li>源抑制(Source Quench): 如果路由器从主机那里收到太多的分组，它可以发送一个信息要求降低分组的传输速度。用于拥塞控制的源抑制报文的格式和差错报告的格式一样，源抑制报文类型为4，码值只能为0。</li>
<li>重定向(Redirect)报文: 在IP网络中，路由选择主要由网络中的路由器来承担。主机只是知道很少的寻径信息，它把非本网的信息往设置的缺省路由器上发送。在一个网络上有两台或多台路由器时，经过缺省路由器虽然可以保证把数据包发送出去，但不能保证对于所有的目的地总是最优的。ICMP中定义的重定向报文，是主机和路由器之间交换路由信息的途径。</li>
</ul>
<h3 id="信息交换报文"><a href="#信息交换报文" class="headerlink" title="信息交换报文"></a>信息交换报文</h3><p>其中请求应答报文主要用于网络诊断。一般成对发送，每一个请求报文对应一种应答报文。包括：</p>
<ul>
<li>回送请求与应答(Echo Request and Rely)：ICMP使用这个分组来确定某具体目的地能否到达。</li>
<li>时戳请求与应答( Timestamp Request and Reply)：时戳分组使主机能估计它到另一个主机间一次来回所需的时间。</li>
<li>地址掩码请求和应答(Address Mask Request and Reply)：主机可以向路由器发送一个地址掩码请求分组来获取它所在网络的网络掩码，路由器会作出应答。</li>
</ul>
<h2 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h2><p>ARP机制实现设备A通过提供设备B的IP地址来获取其MAC地址的方法。</p>
<h3 id="ARP解析缓存"><a href="#ARP解析缓存" class="headerlink" title="ARP解析缓存"></a>ARP解析缓存</h3><ul>
<li>为了避免每发送一个帧都进行ARP过程，使用一种高速缓存技术:运行在每个设备中的软件都维护一个IP地址和硬件地址之间的对应关系表。这样，只在第一次需要使用ARP过程来解析IP地址，然后这一对应关系便被加入到表中。之后，每当需要该设备的硬件地址时，都能在表中查到。</li>
<li>由于ARP请求报文是广播的，则所有站都应捕获到发送设备的IP和MAC地址，并将它们加入到其解析表中。 </li>
<li>解析表中的表项应在一段时间后过期失效。</li>
</ul>
<h2 id="逆向地址解析协议RARP"><a href="#逆向地址解析协议RARP" class="headerlink" title="逆向地址解析协议RARP"></a>逆向地址解析协议RARP</h2><ul>
<li>由设备的硬件地址，查询它所对应的IP地址。 </li>
<li>该协议使用与ARP同样的报文格式，但不同的操作码。</li>
<li>嵌入式无盘系统中的应用，设备可以使用RARP提供硬件地址并请求IP地址。 </li>
</ul>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><ul>
<li>网际层负责不同LAN技术的相互连接，建立一个“虚网”，以允许所有设备能够像在同一个网络中一样互相通信。</li>
<li>IP层的主要功能是封装、分片/重组、编址、交付和选路。</li>
<li>封装是将上一层数据装入一个带有其它控制字段的数据报的过程，其目的是将该分组传递到协议栈的下一层以便发送。 </li>
<li>IP分片过程是将IP数据报分成几个尺寸较小的数据包，以解决一些网络在处理大数据报时可能出现的帧尺寸限制问题。在接收端，重组过程必须将分片数据报重新构成原始数据报。</li>
<li>互连网设备都必须有一个唯一的IP地址。每个IP地址有一个网络ID部分和一个主机ID部分。需要提供合适的编址机制，以便于网络和主机的识别。 </li>
<li>分类编址将整个地址空间分成几类，以适合不同规模的网络。该机制使用效率很低，也不能很好地适合大型网络。子网技术的提出允许网络在内部分成几个子网，该机制的不足是所有子网的尺寸必须相同。变长子网掩码技术克服了这一限制，但仍然不能有效的利用地址空间。无类别编址机制将子网技术应用于整个Internet，是目前使用的技术。 </li>
<li>IP层负责报文交付。直接交付由数据链路层在本地网络完成，间接交付由路由器完成。路由器根据路由表中信息决定传送报文的最佳路径。 </li>
<li>控制报文协议ICMP的作用像是IP的“助理”，为互联网的工作状态提供反馈。该协议主要用于维护、诊断和测试。 </li>
<li>地址解析协议ARP用于将IP地址映射为物理地址。逆向地址解析协议RARP用于将硬件地址映射为IP地址。 </li>
</ul>
<p>–EOF–</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/GitHub-basic-usage/" itemprop="url">
                  GitHub使用初探
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-09T17:09:23+08:00" content="2015-03-09">
              2015-03-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/版本控制/" itemprop="url" rel="index">
                    <span itemprop="name">版本控制</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/GitHub-basic-usage/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="GitHub-basic-usage/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/GitHub-basic-usage/" class="leancloud_visitors" data-flag-title="GitHub使用初探">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>之前申请了GitHub账号，一直都没怎么利用起来。现在开始好好整一下博客，顺便把git的相关知识学一下。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/GitHub-basic-usage/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/algorithm-knowledge-list/" itemprop="url">
                  算法知识清单
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-09T15:54:57+08:00" content="2015-03-09">
              2015-03-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index">
                    <span itemprop="name">Knowledge</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/algorithm-knowledge-list/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="algorithm-knowledge-list/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/algorithm-knowledge-list/" class="leancloud_visitors" data-flag-title="算法知识清单">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Matrix67大神总结的算法清单："><a href="#Matrix67大神总结的算法清单：" class="headerlink" title="Matrix67大神总结的算法清单："></a>Matrix67大神总结的算法清单：</h2><p>时间复杂度（渐近时间复杂度的严格定义，NP问题，时间复杂度的分析方法，主定理）</p>
<p>排序算法（平方排序算法的应用，Shell排序，快速排序，归并排序，时间复杂度下界，三种线性时间排序，外部排序）</p>
<p>数论（整除，集合论，关系，素数，进位制，辗转相除，扩展的辗转相除，同余运算，解线性同余方程，中国剩余定理）</p>
<p>指针（链表，搜索判重，邻接表，开散列，二叉树的表示，多叉树的表示）</p>
<p>按位运算（and，or，xor，shl，shr，一些应用）</p>
<p>图论（图论模型的建立，平面图，欧拉公式与五色定理，求强连通分量，求割点和桥，欧拉回路，AOV问题，AOE问题，最小生成树的三种算法，最短路的三种算法，标号法，差分约束系统，验证二分图，Konig定理，匈牙利算法，KM算法，稳定婚姻系统，最大流算法，最小割最大流定理，最小费用最大流算法）</p>
<p>计算几何（平面解几及其应用，向量，点积及其应用，叉积及其应用，半平面相交，求点集的凸包，最近点对问题，凸多边形的交，离散化与扫描）</p>
<p>数据结构（广度优先搜索，验证括号匹配，表达式计算，递归的编译，Hash表，分段Hash，并查集，Tarjan算法，二叉堆，左偏树，二斜堆，二项堆，二叉查找树，红黑树，AVL平衡树，Treap，Splay，静态二叉查找树，2-d树，线段树，二维线段树，矩形树，Trie树，块状链表）</p>
<p>组合数学（排列与组合，鸽笼原理，容斥原理，递推，Fibonacci数列，Catalan数列，Stirling数，差分序列，生成函数，置换，Polya原理）</p>
<p>概率论（简单概率，条件概率，Bayes定理，期望值）</p>
<p>矩阵（矩阵的概念和运算，二分求解线性递推方程，多米诺骨牌棋盘覆盖方案数，高斯消元）</p>
<p>字符串处理（KMP，后缀树，有限状态自动机，Huffman编码，简单密码学）</p>
<p>动态规划（单调队列，凸完全单调性，树型动规，多叉转二叉，状态压缩类动规，四边形不等式）</p>
<p>博奕论（Nim取子游戏，博弈树，Shannon开关游戏）</p>
<p>搜索（A<em>，ID，IDA</em>，随机调整，遗传算法）</p>
<p>微积分初步（极限思想，导数，积分，定积分，立体解析几何）</p>
<p>PS：知识点会持续更新，不断补充自己的算法知识体系。</p>
<p>–EOF–</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="Jack Jia" />
          <p class="site-author-name" itemprop="name">Jack Jia</p>
          <p class="site-description motion-element" itemprop="description">自由·至简·宁静</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/AjaxJackjia" target="_blank">
                  
                    <i class="fa fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jack Jia</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=0.5.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ajaxjackjia"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

  
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/MathJax.js"></script>
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/config/TeX-AMS-MML_HTMLorMML.js"></script>
  


  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("RpOyfsG0ugnDV6Fg5qbCXNOI-gzGzoHsz", "qa8bUqCM3LW1988c8GgO5XR4");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
